<?xml version="1.0" encoding="UTF-8"?>
<plugins type="array">
  <plugin>
    <account-id type="integer">1</account-id>
    <client-id type="integer">1234</client-id>
    <code>class DiskUsage &lt; Scout::Plugin

  # the Disk Freespace RegEx
  DF_RE = /\A\s*(\S.*?)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*\z/

  # Parses the file systems lines according to the Regular Expression
  # DF_RE.
  # 
  # normal line ex:
  # /dev/disk0s2   233Gi   55Gi  177Gi    24%    /
  
  # multi-line ex:
  # /dev/mapper/VolGroup00-LogVol00
  #                        29G   25G  2.5G  92% /
  #
  def parse_file_systems(io, &amp;line_handler)
    line_handler ||= lambda { |row| pp row }
    headers      =   nil

    row = &quot;&quot;
    io.each do |line|
      if headers.nil? and line =~ /\AFilesystem/
        headers = line.split(&quot; &quot;, 6)
      else
        row &lt;&lt; line
        if row =~  DF_RE
          fields = $~.captures
          line_handler[headers ? Hash[*headers.zip(fields).flatten] : fields]
          row = &quot;&quot;
        end
      end
    end
  end
  
  # Ensures disk space metrics are in GB. Metrics that don't contain 'G,M,or K' are just
  # turned into integers.
  def clean_value(value)
    if value =~ /G/i
      value.to_i
    elsif value =~ /M/i
      (value.to_f/1024.to_f).round
    elsif value =~ /K/i
      (value.to_f/1024.to_f/1024.to_f).round
    else
      value.to_i
    end
  end
  
  def build_report
    ENV['lang'] = 'C' # forcing English for parsing
    df_command   = option(&quot;command&quot;) || &quot;df -h&quot;
    df_output    = `#{df_command}`
          
    df_lines = []
    parse_file_systems(df_output) { |row| df_lines &lt;&lt; row }
    
    # if the user specified a filesystem use that
    df_line = nil
    if option(&quot;filesystem&quot;)
      df_lines.each do |line|
        if line.has_value?(option(&quot;filesystem&quot;))
          df_line = line
        end
      end
    end
    
    # else just use the first line
    df_line ||= df_lines.first
      
    # remove 'filesystem' and 'mounted on' if present - these don't change. 
    df_line.reject! { |name,value| ['filesystem','mounted on'].include?(name.downcase.gsub(/\n/,'')) }  
      
    # capacity on osx = Use% on Linux ... convert anything that isn't size, used, or avail to capacity ... a big assumption?
    assumed_capacity = df_line.find { |name,value| !['size','used','avail'].include?(name.downcase.gsub(/\n/,''))}
    df_line.delete(assumed_capacity.first)
    df_line['capacity'] = assumed_capacity.last
    
    # will be passed at the end to report to Scout
    report_data = Hash.new
      
    df_line.each do |name, value|
      report_data[name.downcase.strip.to_sym] = clean_value(value)
    end
    report(report_data)
  end
end
</code>
    <code-md5-signature>41bb273e1999a894d837dbc1ccc2e709</code-md5-signature>
    <code-updated-at type="datetime">2009-08-26T17:37:55-04:00</code-updated-at>
    <converted-at type="datetime">2009-08-26T17:37:52-04:00</converted-at>
    <created-at type="datetime">2009-08-26T17:37:52-04:00</created-at>
    <created-by-id type="integer">10121</created-by-id>
    <deleted-at type="datetime" nil="true"></deleted-at>
    <enabled type="boolean">true</enabled>
    <error-md5-signature nil="true"></error-md5-signature>
    <failed-at type="datetime" nil="true"></failed-at>
    <failing type="boolean">false</failing>
    <first-reported-at type="datetime">2009-07-09T17:25:07-04:00</first-reported-at>
    <id type="integer">67911</id>
    <interval type="integer">0</interval>
    <last-report-raw type="yaml">--- 
d115471: 349
d115461: 119
d115451: 493
d115481: 75
</last-report-raw>
    <last-reported-at type="datetime">2010-01-21T21:08:00-05:00</last-reported-at>
    <metadata type="yaml">--- 
size: 
  units: GB
  precision: 0
  label: Disk Size
avail: 
  units: GB
  larger_is_better: true
  precision: 0
  label: Disk Space Available
used: 
  units: GB
  precision: 0
  label: Disk Space Used
capacity: 
  units: &quot;%&quot;
  precision: 0
  label: Disk Capacity
</metadata>
    <name>Disk Usage</name>
    <options type="yaml">--- 
command: 
  name: df Command
  default: df -h
  notes: The command used to display free disk space
  value: df -h
filesystem: 
  name: Filesystem
  default: 
  notes: The filesystem to check usage, if none specified, uses the first listed
  value: &quot;&quot;
</options>
    <plugin-url-id type="integer">6</plugin-url-id>
    <rrdb-up-to-date type="boolean">true</rrdb-up-to-date>
    <rrdb-updated-at type="datetime" nil="true"></rrdb-updated-at>
    <schema type="yaml">--- []

</schema>
    <should-retrieve-latest-code type="boolean">false</should-retrieve-latest-code>
    <status nil="true"></status>
    <updated-at type="datetime">2010-01-21T21:08:05-05:00</updated-at>
    <url>http://github.com/highgroove/scout-plugins/raw/master/disk_usage/disk_usage.rb</url>
    <use-rrd type="boolean">true</use-rrd>
    <visualization-enabled type="boolean">true</visualization-enabled>
    <visualization-options nil="true"></visualization-options>
  </plugin>
  <plugin>
    <account-id type="integer">1</account-id>
    <client-id type="integer">1234</client-id>
    <code>class Iostat &lt; Scout::Plugin
  def build_report
    stats = iostat(device)

    counter(:rps,   stats['rio'],        :per =&gt; :second)
    counter(:wps,   stats['wio'],        :per =&gt; :second)
    counter(:rkbps, stats['rsect'] / 2,  :per =&gt; :second)
    counter(:wkbps, stats['wsect'] / 2,  :per =&gt; :second)
    counter(:util,  stats['use'] / 10.0, :per =&gt; :second)

    if old = memory(&quot;#{device}_stats&quot;)
      ios = (stats['rio'] - old['rio']) + (stats['wio']  - old['wio'])

      if ios &gt; 0
        await = ((stats['ruse'] - old['ruse']) + (stats['wuse'] - old['wuse'])) / ios.to_f

        report(:await =&gt; await)
      end
    end

    remember(&quot;#{device}_stats&quot; =&gt; stats)
  end
  
  private
  COLUMNS = %w(major minor name rio rmerge rsect ruse wio wmerge wsect wuse running use aveq)

  def iostat(dev)
    IO.foreach('/proc/diskstats') do |line|
      entry = Hash[*COLUMNS.zip(line.strip.split(/\s+/).collect { |v| Integer(v) rescue v }).flatten]

      return entry if entry['name'] == dev
    end

    nil
  end

  def device
    option('device') || `mount`.grep(/ \/ /)[0].split[0].split('/').last
  end

  # Would be nice to be part of scout internals
  def counter(name, value, options = {}, &amp;block)
    current_time = Time.now

    if data = memory(name)
      last_time, last_value = data[:time], data[:value]
      elapsed_seconds       = current_time - last_time

      # We won't log it if the value has wrapped or enough time hasn't
      # elapsed
      if value &gt;= last_value &amp;&amp; elapsed_seconds &gt;= 1
        if block
          result = block.call(last_value, value)
        else
          result = value - last_value
        end

        case options[:per]
        when :second, 'second'
          result = result / elapsed_seconds.to_f
        when :minute, 'minute'
          result = result / elapsed_seconds.to_f / 60.0
        else
          raise &quot;Unknown option for ':per': #{options[:per].inspect}&quot;
        end

        if options[:round]
          # Backward compatibility
          options[:round] = 1 if options[:round] == true

          result = (result * (10 ** options[:round])).round / (10 ** options[:round]).to_f
        end

        report(name =&gt; result)
      end
    end

    remember(name =&gt; { :time =&gt; current_time, :value =&gt; value })
  end
end
</code>
    <code-md5-signature>d170d7dd7b74fe0a5be58a644291755c</code-md5-signature>
    <code-updated-at type="datetime">2010-01-19T08:02:15-05:00</code-updated-at>
    <converted-at type="datetime">2009-06-26T11:37:39-04:00</converted-at>
    <created-at type="datetime">2009-08-26T17:37:55-04:00</created-at>
    <created-by-id type="integer">10121</created-by-id>
    <deleted-at type="datetime" nil="true"></deleted-at>
    <enabled type="boolean">true</enabled>
    <error-md5-signature nil="true"></error-md5-signature>
    <failed-at type="datetime" nil="true"></failed-at>
    <failing type="boolean">false</failing>
    <first-reported-at type="datetime">2009-07-09T17:25:07-04:00</first-reported-at>
    <id type="integer">67921</id>
    <interval type="integer">0</interval>
    <last-report-raw type="yaml">--- 
d116021: 235.795972866207
d116011: 4.20895422204323
d116001: 464.621741834602
d115991: 27.8808437129647
d116041: 15.0189547902095
d116031: 13393.8158774486
</last-report-raw>
    <last-reported-at type="datetime">2010-01-21T21:08:00-05:00</last-reported-at>
    <metadata type="yaml">--- 
util: 
  units: &quot;%&quot;
  precision: 0
  label: Utilization
wps: 
  precision: 0
  label: Writes/sec
await: 
  units: ms
  precision: 1
  label: I/O Wait
rkbps: 
  units: kB/s
  precision: 1
  label: Read kBps
wkbps: 
  units: kB/s
  precision: 1
  label: Write kBps
rps: 
  precision: 0
  label: Reads/sec
</metadata>
    <name>I/O Stats</name>
    <options type="yaml">--- 
device: 
  name: Device
  default: 
  notes: The device to check, eg 'sda1'. If not specified, uses the device mounted at '/'
  value: xvda1
</options>
    <plugin-url-id type="integer" nil="true"></plugin-url-id>
    <rrdb-up-to-date type="boolean">true</rrdb-up-to-date>
    <rrdb-updated-at type="datetime" nil="true"></rrdb-updated-at>
    <schema type="yaml" nil="true"></schema>
    <should-retrieve-latest-code type="boolean">false</should-retrieve-latest-code>
    <status nil="true"></status>
    <updated-at type="datetime">2010-01-21T21:08:05-05:00</updated-at>
    <url>http://github.com/eric/scout-plugins/raw/master/iostat/iostat.rb</url>
    <use-rrd type="boolean">true</use-rrd>
    <visualization-enabled type="boolean">true</visualization-enabled>
    <visualization-options nil="true"></visualization-options>
  </plugin>
  <plugin>
    <account-id type="integer">1</account-id>
    <client-id type="integer">1234</client-id>
    <code>#
# Modified load_averages to show load/processor, as this is a more accurate
# measurement of CPU utilization.
#
# Requires /proc/cpuinfo
#
class LoadPerProcessor &lt; Scout::Plugin
  TEST_USAGE = &quot;#{File.basename($0)} max_load MAX_LOAD&quot;

   def build_report
     if `uptime` =~ /load average(s*): ([\d.]+)(,*) ([\d.]+)(,*) ([\d.]+)\Z/
       report :last_minute          =&gt; $2.to_f/processors,
              :last_five_minutes    =&gt; $4.to_f/processors,
              :last_fifteen_minutes =&gt; $6.to_f/processors
     else
       raise &quot;Couldn't use `uptime` as expected.&quot;
     end
  rescue Exception
    error &quot;Error determining load&quot;, $!.message
  end

  def processors
    processors = memory(:processors)
    unless processors &amp;&amp; processors &gt; 0
      if `cat /proc/cpuinfo | grep 'model name' | wc -l` =~ /(\d+)/
        processors = $1.to_i
      else
        raise &quot;Couldn't use /proc/cpuinfo as expected.&quot;
      end
      raise &quot;Couldn't use /proc/cpuinfo as expected.&quot; unless processors &gt; 0
    end
    remember(:processors, processors)
    return processors
  end

end
</code>
    <code-md5-signature>4c26a198ba9d9c223026fc51cb9f1b79</code-md5-signature>
    <code-updated-at type="datetime">2009-08-26T17:37:48-04:00</code-updated-at>
    <converted-at type="datetime">2009-08-26T17:37:46-04:00</converted-at>
    <created-at type="datetime">2009-08-26T17:37:46-04:00</created-at>
    <created-by-id type="integer">10121</created-by-id>
    <deleted-at type="datetime" nil="true"></deleted-at>
    <enabled type="boolean">true</enabled>
    <error-md5-signature nil="true"></error-md5-signature>
    <failed-at type="datetime" nil="true"></failed-at>
    <failing type="boolean">false</failing>
    <first-reported-at type="datetime">2009-07-09T17:25:07-04:00</first-reported-at>
    <id type="integer">67891</id>
    <interval type="integer">0</interval>
    <last-report-raw type="yaml">--- 
d116071: 1.40125
d116061: 1.55625
d116051: 1.2675
</last-report-raw>
    <last-reported-at type="datetime">2010-01-21T21:08:00-05:00</last-reported-at>
    <metadata type="yaml">--- 
last_minute: 
  precision: 2
last_five_minutes: 
  precision: 2
last_fifteen_minutes: 
  precision: 2
</metadata>
    <name>Load Per Processor</name>
    <options type="yaml">--- {}

</options>
    <plugin-url-id type="integer" nil="true"></plugin-url-id>
    <rrdb-up-to-date type="boolean">true</rrdb-up-to-date>
    <rrdb-updated-at type="datetime" nil="true"></rrdb-updated-at>
    <schema type="yaml">--- []

</schema>
    <should-retrieve-latest-code type="boolean">false</should-retrieve-latest-code>
    <status nil="true"></status>
    <updated-at type="datetime">2010-01-21T21:08:05-05:00</updated-at>
    <url>http://github.com/jnewland/scout-plugins/raw/master/load_per_processor/load_per_processor.rb</url>
    <use-rrd type="boolean">true</use-rrd>
    <visualization-enabled type="boolean">true</visualization-enabled>
    <visualization-options nil="true"></visualization-options>
  </plugin>
  <plugin>
    <account-id type="integer">1</account-id>
    <client-id type="integer">1234</client-id>
    <code>class MemoryProfiler &lt; Scout::Plugin
  def build_report
    mem_info = {}
    `cat /proc/meminfo`.each do |line|
      _, key, value = *line.match(/^(\w+):\s+(\d+)\s/)
      mem_info[key] = value.to_i
    end
    
    # memory info is empty - operating system may not support it (why doesn't an exception get raised earlier on mac osx?)
    if mem_info.empty?
      raise &quot;No such file or directory&quot;
    end
    
    mem_total = mem_info['MemTotal'] / 1024
    mem_free = (mem_info['MemFree'] + mem_info['Buffers'] + mem_info['Cached']) / 1024
    mem_used = mem_total - mem_free
    mem_percent_used = (mem_used / mem_total.to_f * 100).to_i

    swap_total = mem_info['SwapTotal'] / 1024
    swap_free = mem_info['SwapFree'] / 1024
    swap_used = swap_total - swap_free
    unless swap_total == 0    
      swap_percent_used = (swap_used / swap_total.to_f * 100).to_i
    end
    
    # will be passed at the end to report to Scout
    report_data = Hash.new

    report_data['Memory Total'] = mem_total
    report_data['Memory Used'] = mem_used
    report_data['% Memory Used'] = mem_percent_used

    report_data['Swap Total'] = swap_total
    report_data['Swap Used'] = swap_used
    unless  swap_total == 0   
      report_data['% Swap Used'] = swap_percent_used
    end
    report(report_data)
        
  rescue Exception =&gt; e
    if e.message =~ /No such file or directory/
      error('Unable to find /proc/meminfo',%Q(Unable to find /proc/meminfo. Please ensure your operationg system supports procfs:
         http://en.wikipedia.org/wiki/Procfs)
      )
    else
      raise
    end
  end
end
</code>
    <code-md5-signature>a69ce86644d659242ac916be1a54d51f</code-md5-signature>
    <code-updated-at type="datetime">2009-08-26T17:37:49-04:00</code-updated-at>
    <converted-at type="datetime">2009-08-26T17:37:49-04:00</converted-at>
    <created-at type="datetime">2009-08-26T17:37:49-04:00</created-at>
    <created-by-id type="integer">10121</created-by-id>
    <deleted-at type="datetime" nil="true"></deleted-at>
    <enabled type="boolean">true</enabled>
    <error-md5-signature nil="true"></error-md5-signature>
    <failed-at type="datetime" nil="true"></failed-at>
    <failing type="boolean">false</failing>
    <first-reported-at type="datetime">2009-07-09T17:25:07-04:00</first-reported-at>
    <id type="integer">67901</id>
    <interval type="integer">0</interval>
    <last-report-raw type="yaml">--- 
d115541: 2
d115531: 63000
d115521: 54802
d115511: 86
d115491: 0
d115501: 511
</last-report-raw>
    <last-reported-at type="datetime">2010-01-21T21:08:00-05:00</last-reported-at>
    <metadata type="yaml">--- 
&quot;% Swap Used&quot;: 
  units: &quot;%&quot;
  precision: 0
&quot;% Memory Used&quot;: 
  units: &quot;%&quot;
  precision: 0
Swap Total: 
  units: MB
  precision: 0
Memory Used: 
  units: MB
  precision: 0
Memory Total: 
  units: MB
  larger_is_better: true
  precision: 0
Swap Used: 
  units: MB
  precision: 0
</metadata>
    <name>Memory Profiler</name>
    <options type="yaml">--- {}

</options>
    <plugin-url-id type="integer">15</plugin-url-id>
    <rrdb-up-to-date type="boolean">true</rrdb-up-to-date>
    <rrdb-updated-at type="datetime" nil="true"></rrdb-updated-at>
    <schema type="yaml">--- []

</schema>
    <should-retrieve-latest-code type="boolean">false</should-retrieve-latest-code>
    <status nil="true"></status>
    <updated-at type="datetime">2010-01-21T21:08:05-05:00</updated-at>
    <url>http://github.com/highgroove/scout-plugins/raw/master/memory_profiler/memory_profiler.rb</url>
    <use-rrd type="boolean">true</use-rrd>
    <visualization-enabled type="boolean">true</visualization-enabled>
    <visualization-options nil="true"></visualization-options>
  </plugin>
</plugins>